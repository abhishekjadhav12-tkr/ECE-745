`timescale 1ns / 10ps
module top();

  parameter int WB_ADDR_WIDTH  = 2;
  parameter int WB_DATA_WIDTH  = 8;
  parameter int NUM_I2C_BUSSES = 1;

  // ----------------------------
  // Wishbone + system signals
  // ----------------------------
  logic  clk;
  logic  rst;
  wire   cyc;
  wire   stb;
  wire   we;
  tri1   ack;
  wire [WB_ADDR_WIDTH-1:0] adr;
  wire [WB_DATA_WIDTH-1:0] dat_wr_o;
  wire [WB_DATA_WIDTH-1:0] dat_rd_i;
  wire   irq;

  // ----------------------------
  // I2C busses (pulled-up)
  // ----------------------------
  tri1 [NUM_I2C_BUSSES-1:0] scl;
  tri1 [NUM_I2C_BUSSES-1:0] sda;

  // DUT I2C outputs (separate, then open-drain onto scl/sda)
  //wire [NUM_I2C_BUSSES-1:0] dut_scl_o;
  //wire [NUM_I2C_BUSSES-1:0] dut_sda_o;

  // ----------------------------
  // DEBUG: prove correct top.sv is compiled
  // ----------------------------
  initial $display("USING TOP.SV VERSION: OPEN_DRAIN_WRAPPER_ENABLED");

  // ----------------------------
  // Clock generator (10ns period)
  // ----------------------------
  initial clk = 1'b0;
  always #5 clk = ~clk;

  // ----------------------------
  // Reset generator
  // ----------------------------
  initial begin
    rst = 1'b1;
    #113;
    rst = 1'b0;
  end

  // ----------------------------
  // Register addresses
  // ----------------------------
  localparam logic [WB_ADDR_WIDTH-1:0] CSR_ADDR  = 2'h0;
  localparam logic [WB_ADDR_WIDTH-1:0] DPR_ADDR  = 2'h1;
  localparam logic [WB_ADDR_WIDTH-1:0] CMDR_ADDR = 2'h2;
  localparam logic [WB_ADDR_WIDTH-1:0] FSMR_ADDR = 2'h3;

  // ----------------------------
  // Example tasks
  // ----------------------------
  task automatic example_1();
    wb_bus.master_write(CSR_ADDR, 8'hC0);
  endtask

  task automatic example_3();
    bit [7:0] status;

    wb_bus.master_write(DPR_ADDR, 8'h05);    // select bus 5
    wb_bus.master_write(CMDR_ADDR, 8'b110);  // set bus cmd

    do wb_bus.master_read(CMDR_ADDR, status);
    while (status[7:4] == 4'b0000 || irq == 1'h1);

    wb_bus.master_write(CMDR_ADDR, 8'b100);  // START
    wb_bus.master_read(CMDR_ADDR, status);

    do begin
      @(posedge clk);
      wb_bus.master_read(CMDR_ADDR, status);
    end while (status[7:4] == 4'b0000 || irq == 1'h1);

    wb_bus.master_write(DPR_ADDR, 8'h44);    // address byte
    wb_bus.master_write(CMDR_ADDR, 8'b001);  // WRITE

    do begin
      @(posedge clk);
      wb_bus.master_read(CMDR_ADDR, status);
    end while (status[7:4] == 4'b0000 || irq == 1'h1);

    wb_bus.master_write(DPR_ADDR, 8'h78);    // data byte
    wb_bus.master_write(CMDR_ADDR, 8'b001);  // WRITE

    do begin
      @(posedge clk);
      wb_bus.master_read(CMDR_ADDR, status);
    end while (status[7:4] == 4'b0000 || irq == 1'h1);

    wb_bus.master_write(CMDR_ADDR, 8'b101);  // STOP

    do begin
      @(posedge clk);
      wb_bus.master_read(CMDR_ADDR, status);
    end while (status[7:4] == 4'b0000 || irq == 1'h1);
  endtask

  // ----------------------------
  // Main test sequence
  // ----------------------------
  initial begin : main_test
    wait (rst == 1'b0);
    @(posedge clk);

    example_1();
    $display("Example 1 done");

    example_3();
    $display("Example 3 done");

    #2000;
    $finish;
  end

  // ----------------------------
  // Instantiate i2c_if on bus 5
  // ----------------------------
  i2c_if i2c_bus (
    .SCL(scl[0]),
    .SDA(sda[0])
  );

  // ----------------------------
  // Open-drain wrapper for DUT outputs onto pulled-up busses
  // Only drive 0; otherwise release Z (prevents X/1 from corrupting bus)
  /*
  genvar k;
  generate
    for (k = 0; k < NUM_I2C_BUSSES; k++) begin : OD
      assign scl[k] = (dut_scl_o[k] === 1'b0) ? 1'b0 : 1'bz;
      assign sda[k] = (dut_sda_o[k] === 1'b0) ? 1'b0 : 1'bz;
    end
  endgenerate

  */
  // I2C Slave response thread (single listener)
  // ----------------------------
  initial begin : i2c_slave_response
    bit       op;
    bit [7:0] write_data[];
    bit       done;
    bit [7:0] rdata[];

    wait (rst == 1'b0);

    forever begin
      i2c_bus.wait_for_i2c_transfer(op, write_data);

      if (op == 1'b0) begin
        $display("I2C_BUS WRITE Transfer: addr=0x%02h, data[0]=0x%02h",
                 8'h44, write_data.size() ? write_data[0] : 8'h00);
      end else begin
        rdata = new[1];
        rdata[0] = 8'hAA;
        i2c_bus.provide_read_data(rdata, done);

        $display("I2C_BUS READ  Transfer: addr=0x%02h, data[0]=0x%02h",
                 8'h44, rdata[0]);
      end
    end
  end

  // ----------------------------
  // Wishbone master BFM
  // ----------------------------
  wb_if #(
    .ADDR_WIDTH(WB_ADDR_WIDTH),
    .DATA_WIDTH(WB_DATA_WIDTH)
  ) wb_bus (
    .clk_i(clk),
    .rst_i(rst),

    .cyc_o(cyc),
    .stb_o(stb),
    .ack_i(ack),
    .adr_o(adr),
    .we_o(we),

    .cyc_i(),
    .stb_i(),
    .ack_o(),
    .adr_i(),
    .we_i(),

    .dat_o(dat_wr_o),
    .dat_i(dat_rd_i)
  );

  // ----------------------------
  // DUT - I2C Multi-Bus Controller
  // IMPORTANT: scl_o/sda_o go to dut_*_o, NOT to scl/sda directly
  // ----------------------------
  iicmb_m_wb #(.g_bus_num(NUM_I2C_BUSSES)) DUT (
    .clk_i(clk),
    .rst_i(rst),

    .cyc_i(cyc),
    .stb_i(stb),
    .ack_o(ack),
    .adr_i(adr),
    .we_i(we),
    .dat_i(dat_wr_o),
    .dat_o(dat_rd_i),

    .irq(irq),

    .scl_i(scl),
    .sda_i(sda),
    .scl_o(dut_scl_o),
    .sda_o(dut_sda_o)
  );

endmodule
